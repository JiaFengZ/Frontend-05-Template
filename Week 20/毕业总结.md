
## 课程回顾
参加课程的主要目的是完善自己的知识体系，由于个人原因结果差强人意，大概是有了一个雏形：
* 数据结构和算法
  * 三子棋/五子棋
  * 路径启发式搜索
  * 四则运算ast解析
* html渲染解析原理
  * http协议，requset和response body报文的解析
  * html标签解析、css计算、布局计算、渲染绘图
* 浏览器Api
  * 实现了一个简易的浏览器模型
    * 实现Request，可以构造发送http报文
    * 实现ResponseParser，可以接受解析http报文
    * 实现了一个html parser，解析html标签文本，构造成ast语法树
    * 实现了一个css computer，匹配计算元素css属性，构成css属性树
    * 实现 css layout，可以完成基于flex的布局
    * 利用images库简陋地模拟了绘图
* 前端框架
  * 实现一个玩具版的toyreact框架：抽象元素对象构成虚拟dom的概念模型、在vdom的模型上实现数据驱动渲染、通过setState更新vdom、实现vdom的比对更新算法
* 前端工程化
  * 前端项目脚手架 Yeoman 
  * eslint代码格式检查
  * git hooks集成发布
  * 自动化测试工具

## 关于个人的一些摸索经历
### 对于 MVVM 框架的粗浅认识
* 框架解决的问题？
在框架诞生前，jquery时代就是直接操纵页面DOM元素，获取元素，设置元素的 innerHTML 展示相应的数据。 这样直接操作页面元素是很低效繁琐的，框架的诞生就是为了让我们的注意力只关注数据的输入输出，事件的交互。解决以下两个问题：
  * 从数据到页面输出渲染
  * 从事件操作到更新数据
* angularjs(1.x)、React、Vue框架
  * angularjs(1.x)：脏值检查，遍历观察者，判断改变前后值是否发生变化，是主动的。具体在angular中的实现就是： 解析模版过程中给元素节点绑定事件，同样根据双大括号的标识输出渲染结果，在angularjs的函数作用域内执行事件方法完毕后会触发脏值检测循环， 一旦检测数据模型scope中的数据发生变化，就会根据相应的输出标记把数据更新渲染到界面上。触发变动的来源有：用户事件的输入、内部数据的输入变动。（注：2016-2017使用）
  * Vue2.0： 劫持数据的改变行为，和界面渲染形成双向绑定的关系（注：2018短暂使用）
  * React：不需要检测数据的变化，采取的不是双向数据绑定的策略，而是单向数据流的理念，数据状态存储在state中， 主动调用setState更新，生成虚拟DOM，进行diffs对比直接更新DOM树（注：2019-使用）
### 对于组件化目前的理解
* 组件的概念？
封装数据获取，渲染展示和事件交互的逻辑，自成一体，完成特定的功能。
但是不存再纯自治的组件，完整的应用需要不同的组件组合而成，既然是组合，就必然会
产生数据的传递，事件交互的通信，所以组件功能内聚和组件交互通信是有矛盾的关系的，
但是恰恰又因为组件功能内聚的概念，划分出不同的组件模块，才会有数据传递通信交流
的存在，如果没有组件的概念，就是自成一团内耗了。越复杂的应用，组件就划分得越多，
组件间的通信耦合也会越复杂。
* 组件划分的方法
  * 从功能分类上来看：
    * 对UI界面进行划分的UI组件
    * 对业务逻辑划分的业务组件
    * 完成特定交互需求的功能性组件
  * 从编码组织角度上来看：
    * 容器组件：组合各个实现具体逻辑的业务组件的容器，负责和store通信，管理集中的数据
    * 逻辑组件：实现具体业务逻辑代码细节的组件，管理自身状态，处理事件交互
    * 布局组件：layout，是页面布局结构的抽象，可填充具体业务组件
    * 纯展示组件：无状态组件，纯粹根据props渲染，以及向上转发事件
* 组件间的数据通信（耦合）
  * prop传递父组件数据
  * 子组件订阅父组件事件，传递通知
  * 子组件通过callback传递数据给父组件
  * 兄弟组件通过store通信
  * 兄弟组件状态提升，通过共同父组件通信
* 组件内的逻辑分层：
如果说组件的细粒度分割是横向的代码划分，那么组件内的逻辑分层，可以看作纵向的代码划分。如果某个组件已经不适宜通过
拆分成小组件的方式降低代码复杂度，那就可以考虑从代码逻辑上分层从而降低代码复杂度，编写出更易阅读维护的代码。

### 关于React组件单元测试的一些摸索尝试
* 测试金字塔：测试从上到下分为 UI（用户界面测试）/Service（服务测试） /Unit（单元测试 ），针对组件库，显然需要的是Unit（单元测试 ）。而且
UI测试最不稳定，性价比最低，业务逻辑服务测试次之，故在时间成本有限的情况下，最稳定和最优先考虑的应该是单元测试。
* 怎么样的代码值得测试？
  * 能快速而且反复的进行测试，替代部分人工测试
  * 迭代周期长/生命周期长、渐进式迭代的代码尤其需要自动化测试保证功能稳定
* 选用什么测试框架？
  * jest：facebook推出的一个js前端测试框架，提供了很多辅助工具，方便测试函数，代码。同时提供了对react的dom元素快照测试的能力，纯函数，断言库，比对输出是否相等
  * enzyme：提供了一个dom模拟环境，可以测试dom元素的渲染结果以及模拟测试用户事件交互。基本可以覆盖react前端应用的所有的测试场景
    * Shallow (shallow)：可调用组件的生命周期函数；浅层渲染根组件，不渲染子组件；可测试渲染dom结果是否符合预期；不可测试事件交互
    * Full Rendering(mount)：完全渲染挂载组件树；可测试dom渲染结果是否符合预期；提供全局的DOM API模拟环境，浏览器模拟环境，可测试事件交互
    * Static Rendering(render)：静态渲染；测试dom html渲染结果，分析html结构是否符合预期
* 如何写测试？
  * 关注输出结果，不关注内部实现
  * 测试渲染结果是否符合预期以及事件行为是否符合预期
  * 测试用例独立，互不影响
  * 测试用例运行结果应该是稳定的，不依赖于时间、环境等变量因素

### 对canvas和WebGL的学习
浏览器提供了2D和3D绘图能力的API支持，对此略有学习涉猎：
* [canvas image](https://github.com/JiaFengZ/canvas-image)
* [webgl-practice](https://github.com/JiaFengZ/webgl-practice)
* [webgl-cargame](https://github.com/JiaFengZ/webgl-cargame)
